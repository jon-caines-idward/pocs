/**
 * ==================================================================================
 * ANONYMISED SIGNAL LIFT METHODOLOGY
 * ==================================================================================
 *
 * OBJECTIVE:
 * Estimate the direct revenue impact of SignalLift on ad requests containing PPID 
 * and PPS signals versus ad requests without these signals, using GAM reporting 
 * data from Ad Exchange (AdX) and Ad Server (AdS) channels.
 *
 * ==================================================================================
 * RANDOMISED CONTROL TRIAL DESIGN:
 * ==================================================================================
 *
 * TREATMENT GROUP (TG):
 *   Ad requests containing PPID and/or PPS signals with Active status
 *
 * CONTROL GROUP (CG):
 *   Ad requests where signals were deliberately withheld (PPID = Missing, CD0 = 8)
 *
 * KEY VALUE (CD0) ASSIGNMENTS:
 *   - CD0 = 1: PPID-only signal set
 *   - CD0 = 2: PPS-only signal set (not analyzed separately)
 *   - CD0 = 3: Combined Signals (PPID + PPS both set)
 *   - CD0 = 8: Control Group (signals deliberately withheld)
 *
 * ==================================================================================
 * CRITICAL DIMENSIONS FOR MEASUREMENT:
 * ==================================================================================
 *
 * 1. PPID STATUS (Publisher Provided Identifier):
 *    - Active: PPID present in ad request and usable by Google
 *    - Missing: PPID not present in ad request
 *    - Restricted: PPID present but cannot be used due to consent restrictions
 *
 * 2. THIRD-PARTY ID STATUS (e.g., cookies, MAIDs):
 *    - Active: Third-party identifier present and usable
 *    - Missing: No third-party identifier present
 *    - Restricted: Third-party ID present but restricted by consent
 *
 * 3. DEMAND CHANNEL:
 *    - AD_EXCHANGE (AdX): Programmatic auction revenue
 *    - AD_SERVER (AdS): Direct and other ad server revenue
 *
 * ==================================================================================
 * SIGNAL TYPE ISOLATION LOGIC:
 * ==================================================================================
 *
 * PPID-ONLY (CD0 = 1):
 * --------------------
 * To isolate the pure impact of PPID, we MUST exclude impressions with third-party 
 * IDs, as we cannot decouple PPID's revenue contribution from third-party signals.
 *
 *   Treatment Group (TG):
 *     - CD0 = 1 (PPID-only signal set)
 *     - PPID Status = Active
 *     - Third-party ID Status = Missing
 *
 *   Control Group (CG):
 *     - CD0 = 8 (control group)
 *     - PPID Status = Missing
 *     - Third-party ID Status = Missing
 *
 * COMBINED SIGNALS (CD0 = 3):
 * ---------------------------
 * PPS (Publisher Provided Signals) adds value to BOTH PPIDs and third-party IDs,
 * therefore we include ALL third-party ID statuses in the analysis.
 *
 *   Treatment Group (TG):
 *     - CD0 = 3 (Combined signals set)
 *     - PPID Status = Active
 *     - Third-party ID Status = Any (Active or Missing)
 *
 *   Control Group (CG):
 *     - CD0 = 8 (control group)
 *     - PPID Status = Missing
 *     - Third-party ID Status = Any (Active or Missing)
 *
 * ==================================================================================
 * EXCLUSIONS (Applied to Both Signal Types):
 * ==================================================================================
 *
 * - PPID Status = Restricted (unusable by Google due to consent)
 * - Third-party ID Status = Restricted (unusable by Google due to consent)
 * - CD0 = (not applicable) or empty
 * - Demand Channel ≠ AD_EXCHANGE and ≠ AD_SERVER
 *
 * Restricted signals would negatively affect impression value and skew results.
 *
 * ==================================================================================
 * CALCULATION METHODOLOGY:
 * ==================================================================================
 *
 * For each Signal Type (PPID-only and Combined Signals) and Channel (AdX, AdS):
 *
 * Step 1: Aggregate by date
 *   - Sum impressions, revenue, and ad requests for TG and CG separately
 *
 * Step 2: Calculate eCPM (effective Cost Per Mille)
 *   - TG eCPM = (TG Revenue / TG Ad Requests) × 1000
 *   - CG eCPM = (CG Revenue / CG Ad Requests) × 1000
 *   
 *   Note: eCPM combines both CPM and fill rate into a single metric
 *
 * Step 3: Calculate eCPM Uplift
 *   - eCPM Uplift = TG eCPM - CG eCPM
 *   - eCPM % Uplift = (eCPM Uplift / CG eCPM) × 100%
 *
 * Step 4: Calculate Revenue Uplift
 *   - Revenue Uplift = (eCPM Uplift × TG Ad Requests) / 1000
 *   
 *   This represents the incremental revenue generated by the signals
 *
 * ==================================================================================
 * METRICS CALCULATED:
 * ==================================================================================
 *
 * Per Group (TG and CG):
 *   - Total Impressions (filled ad requests)
 *   - Total Revenue (from GAM)
 *   - Total Ad Requests (filled + unfilled impressions)
 *   - Unfilled Impressions (Ad Requests - Impressions)
 *   - eCPM (Revenue / Ad Requests × 1000)
 *
 * Uplift Metrics:
 *   - eCPM Uplift (absolute difference)
 *   - eCPM % Uplift (percentage improvement)
 *   - Revenue Uplift (incremental revenue from signals)
 *
 * ==================================================================================
 * OUTPUT STRUCTURE:
 * ==================================================================================
 *
 * Two separate output sheets are generated:
 *
 * 1. "PPID-only Uplift"
 *    - Shows isolated impact of PPID signal alone
 *    - Excludes third-party ID interference
 *
 * 2. "Combined Signals Uplift"
 *    - Shows combined impact of PPID + PPS signals
 *    - Includes all third-party ID scenarios
 *
 * Each sheet contains daily metrics and a totals row with aggregated/averaged values.
 *
 * ==================================================================================
 */

function buildASLReportv2() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sourceSheet = ss.getSheets()[0]; // raw tab, untouched

  // Step 1: Read header row and dynamically map column indices
  const header = sourceSheet
    .getRange(1, 1, 1, sourceSheet.getLastColumn())
    .getValues()[0];

  const safeColIndex = (name) => {
    const idx = header.indexOf(name);
    return idx === -1 ? null : idx;
  };

  // Map column indices from GAM export
  const DATE_COL           = safeColIndex('Date');
  const CD0_COL            = safeColIndex('Anonymised Signal Lift assigned (anonymisedsignallift)');
  const PPID_STATUS_COL    = safeColIndex('PPID status');
  const TPID_STATUS_COL    = safeColIndex('Third-party ID status');
  const DEMAND_CHANNEL_COL = safeColIndex('Demand channel');
  const IMPRESSIONS_COL    = safeColIndex('Total impressions');
  const ADX_REV_COL        = safeColIndex('Ad Exchange revenue'); 
  const ADS_REV_COL        = safeColIndex('Ad server total revenue'); 
  const AD_REQUESTS_COL    = safeColIndex('Total ad requests'); 

  // Validate required columns are present
  if (DATE_COL === null || PPID_STATUS_COL === null || DEMAND_CHANNEL_COL === null || 
      CD0_COL === null || TPID_STATUS_COL === null) {
    const outputSheet = ss.getSheetByName('Error Log') || ss.insertSheet('Error Log');
    outputSheet.clearContents();
    outputSheet.getRange(1, 1).setValue(
      'ERROR: Missing required columns. This script requires: Date, PPID status, ' +
      'Third-party ID status, Demand channel, and Anonymised Signal Lift assigned (CD0)'
    );
    return;
  }

  // Set limits
  const lastRow = sourceSheet.getLastRow();
  const lastCol = sourceSheet.getLastColumn();
  const CHUNK_SIZE = 2000;

  // Initialize data structures for Treatment and Control groups
  // Structure: { signalType: { channel: { date: { impressions, revenue, adRequests } } } }
  
  // Treatment Group data (PPID Status = Active)
  const treatmentData = {
    ppidOnly: { adx: {}, ads: {} },      // CD0=1, Third-party ID=Missing
    combined: { adx: {}, ads: {} }       // CD0=3, any Third-party ID status
  };
  
  // Control Group data (PPID Status = Missing, CD0=8)
  const controlData = {
    ppidOnly: { adx: {}, ads: {} },      // CD0=8, Third-party ID=Missing
    combined: { adx: {}, ads: {} }       // CD0=8, any Third-party ID status
  };

  // Helper function: Convert date values to consistent YYYY-MM-DD string format
  function ensureDateKey(value) {
    if (value instanceof Date) {
      return Utilities.formatDate(value, Session.getScriptTimeZone(), 'yyyy-MM-dd');
    }
    return String(value);
  }

  // Helper function: Accumulate metrics (impressions, revenue, ad requests) for a given date
  function addToMap(map, dateKey, impressions, revenue, adRequests) {
    if (!map[dateKey]) {
      map[dateKey] = { impressions: 0, revenue: 0, adRequests: 0 };
    }
    map[dateKey].impressions += Number(impressions) || 0;
    map[dateKey].revenue += Number(revenue) || 0;
    map[dateKey].adRequests += Number(adRequests) || 0;
  }

  // Helper function: Merge source map into target map (for combining chunk results)
  function mergeMaps(target, source) {
    Object.keys(source).forEach(dateKey => {
      addToMap(
        target,
        dateKey,
        source[dateKey].impressions,
        source[dateKey].revenue,
        source[dateKey].adRequests
      );
    });
  }

  // Helper function: Defensive normalisation for status fields 
  function normaliseStatus(value) {
    const v = String(value || '').trim().toLowerCase();
    if (v === 'active') return 'Active';
    if (v === 'missing') return 'Missing';
    if (v === 'restricted') return 'Restricted';
    return v;
  }

  // Step 2: Process source data in chunks for performance optimization
  for (let startRow = 2; startRow <= lastRow; startRow += CHUNK_SIZE) {
    const numRows = Math.min(CHUNK_SIZE, lastRow - startRow + 1);
    const chunkRange = sourceSheet.getRange(startRow, 1, numRows, lastCol);
    const chunkValues = chunkRange.getValues();

    // Initialize local chunk-level maps (will be merged into global maps)
    const localTreatment = {
      ppidOnly: { adx: {}, ads: {} },
      combined: { adx: {}, ads: {} }
    };
    
    const localControl = {
      ppidOnly: { adx: {}, ads: {} },
      combined: { adx: {}, ads: {} }
    };

    // Step 3: Process each row in the current chunk
    for (let i = 0; i < chunkValues.length; i++) {
      const row = chunkValues[i];

      // Extract key dimension values
      const cd0        = String(row[CD0_COL] || '');
      const ppidStatus = normaliseStatus(row[PPID_STATUS_COL] || '');
      const tpidStatus = normaliseStatus(row[TPID_STATUS_COL] || '');
      const demand     = String(row[DEMAND_CHANNEL_COL] || '');

      // FILTER 1: Skip rows with no signal assignment
      if (cd0 === '' || cd0 === '(not applicable)') continue;

      // FILTER 2: Exclude Restricted statuses (unusable by Google, would skew results)
      if (ppidStatus === 'Restricted' || tpidStatus === 'Restricted') continue;

      // FILTER 3: Only process the two main demand channels
      if (demand !== 'AD_EXCHANGE' && demand !== 'AD_SERVER') continue;

      // Extract metric values
      const dateKey     = ensureDateKey(row[DATE_COL]);
      const impressions = IMPRESSIONS_COL !== null ? row[IMPRESSIONS_COL] : 0;
      const adxRev      = ADX_REV_COL !== null ? row[ADX_REV_COL] : 0;
      const adsRev      = ADS_REV_COL !== null ? row[ADS_REV_COL] : 0;
      const adRequests  = AD_REQUESTS_COL !== null ? row[AD_REQUESTS_COL] : 0;

      // Determine channel and select appropriate revenue
      const channel = demand === 'AD_EXCHANGE' ? 'adx' : 'ads';
      const revenue = demand === 'AD_EXCHANGE' ? adxRev : adsRev;

      // Step 4: Classify and accumulate data based on signal type and group
      
      // PPID-ONLY SIGNAL (CD0=1): Requires Third-party ID = Missing to isolate PPID impact
      if (cd0 === '1' && tpidStatus === 'Missing') {
        if (ppidStatus === 'Active') {
          // Treatment Group: PPID signal is active
          addToMap(localTreatment.ppidOnly[channel], dateKey, impressions, revenue, adRequests);
        }
      }

      // COMBINED SIGNALS (CD0=3): Includes all Third-party ID statuses
      // (PPS adds value to both PPID and third-party IDs)
      if (cd0 === '3') {
        if (ppidStatus === 'Active') {
          // Treatment Group: Combined signals active
          addToMap(localTreatment.combined[channel], dateKey, impressions, revenue, adRequests);
        }
      }

      // CONTROL GROUP (CD0=8): PPID deliberately withheld
      if (cd0 === '8' && ppidStatus === 'Missing') {
        // For PPID-only comparison: Match TG by requiring Third-party ID = Missing
        if (tpidStatus === 'Missing') {
          addToMap(localControl.ppidOnly[channel], dateKey, impressions, revenue, adRequests);
        }
        // For Combined Signals comparison: Include all Third-party ID statuses
        addToMap(localControl.combined[channel], dateKey, impressions, revenue, adRequests);
      }
    }

    // Step 5: Merge chunk results into global aggregated maps
    mergeMaps(treatmentData.ppidOnly.adx, localTreatment.ppidOnly.adx);
    mergeMaps(treatmentData.ppidOnly.ads, localTreatment.ppidOnly.ads);
    mergeMaps(treatmentData.combined.adx, localTreatment.combined.adx);
    mergeMaps(treatmentData.combined.ads, localTreatment.combined.ads);
    
    mergeMaps(controlData.ppidOnly.adx, localControl.ppidOnly.adx);
    mergeMaps(controlData.ppidOnly.ads, localControl.ppidOnly.ads);
    mergeMaps(controlData.combined.adx, localControl.combined.adx);
    mergeMaps(controlData.combined.ads, localControl.combined.ads);
  }

  // Step 6: Generate output reports for each signal type
  generateOutput(ss, 'PPID-only Uplift', treatmentData.ppidOnly, controlData.ppidOnly);
  generateOutput(ss, 'Combined Signals Uplift', treatmentData.combined, controlData.combined);
}

/**
 * Generate output sheet with calculated uplift metrics
 * 
 * @param {Spreadsheet} ss - Active spreadsheet object
 * @param {string} sheetName - Name for the output sheet
 * @param {Object} treatment - Treatment group data by channel and date
 * @param {Object} control - Control group data by channel and date
 */
function generateOutput(ss, sheetName, treatment, control) {
  let outputSheet = ss.getSheetByName(sheetName);
  if (!outputSheet) {
    outputSheet = ss.insertSheet(sheetName);
  } else {
    outputSheet.clearContents();
  }

  // Collect all unique dates across both treatment and control groups
  const allDateKeys = new Set([
    ...Object.keys(treatment.adx),
    ...Object.keys(treatment.ads),
    ...Object.keys(control.adx),
    ...Object.keys(control.ads)
  ]);

  if (allDateKeys.size === 0) {
    outputSheet.getRange(1, 1).setValue('No data found for this signal type');
    return;
  }

  const resultRows = [];
  
  // Calculate metrics for each date
  allDateKeys.forEach(dateKey => {
    // Get data for each group/channel combination (default to zeros if no data)
    const tgAdx = treatment.adx[dateKey] || { impressions: 0, revenue: 0, adRequests: 0 };
    const cgAdx = control.adx[dateKey] || { impressions: 0, revenue: 0, adRequests: 0 };
    const tgAds = treatment.ads[dateKey] || { impressions: 0, revenue: 0, adRequests: 0 };
    const cgAds = control.ads[dateKey] || { impressions: 0, revenue: 0, adRequests: 0 };

    const dateObj = new Date(dateKey);

    // AD EXCHANGE CALCULATIONS
    // eCPM = (Revenue / Ad Requests) × 1000
    const tgAdxEcpm = tgAdx.adRequests > 0 ? (tgAdx.revenue / tgAdx.adRequests * 1000) : 0;
    const cgAdxEcpm = cgAdx.adRequests > 0 ? (cgAdx.revenue / cgAdx.adRequests * 1000) : 0;
    
    // Uplift = TG eCPM - CG eCPM
    const adxEcpmUplift = tgAdxEcpm - cgAdxEcpm;
    
    // % Uplift = (Uplift / CG eCPM) × 100%
    const adxEcpmPercentUplift = cgAdxEcpm !== 0 ? (adxEcpmUplift / cgAdxEcpm) : 0;
    
    // Revenue Uplift = (eCPM Uplift × TG Ad Requests) / 1000
    const adxRevenueUplift = (tgAdx.adRequests * adxEcpmUplift) / 1000;

    // AD SERVER CALCULATIONS (same methodology)
    const tgAdsEcpm = tgAds.adRequests > 0 ? (tgAds.revenue / tgAds.adRequests * 1000) : 0;
    const cgAdsEcpm = cgAds.adRequests > 0 ? (cgAds.revenue / cgAds.adRequests * 1000) : 0;
    const adsEcpmUplift = tgAdsEcpm - cgAdsEcpm;
    const adsEcpmPercentUplift = cgAdsEcpm !== 0 ? (adsEcpmUplift / cgAdsEcpm) : 0;
    const adsRevenueUplift = (tgAds.adRequests * adsEcpmUplift) / 1000;

    // Build output row with all metrics
    resultRows.push([
      dateObj,
      // Ad Exchange - Treatment Group (TG)
      tgAdx.impressions,
      tgAdx.revenue,
      tgAdx.adRequests,
      tgAdx.adRequests - tgAdx.impressions, // Unfilled impressions
      tgAdxEcpm,
      // Ad Exchange - Control Group (CG)
      cgAdx.impressions,
      cgAdx.revenue,
      cgAdx.adRequests,
      cgAdx.adRequests - cgAdx.impressions, // Unfilled impressions
      cgAdxEcpm,
      // Ad Exchange - Uplift Metrics
      adxEcpmUplift,
      adxEcpmPercentUplift,
      adxRevenueUplift,
      // Ad Server - Treatment Group (TG)
      tgAds.impressions,
      tgAds.revenue,
      tgAds.adRequests,
      tgAds.adRequests - tgAds.impressions, // Unfilled impressions
      tgAdsEcpm,
      // Ad Server - Control Group (CG)
      cgAds.impressions,
      cgAds.revenue,
      cgAds.adRequests,
      cgAds.adRequests - cgAds.impressions, // Unfilled impressions
      cgAdsEcpm,
      // Ad Server - Uplift Metrics
      adsEcpmUplift,
      adsEcpmPercentUplift,
      adsRevenueUplift,
    ]);
  });

  // Sort results by date (ascending)
  resultRows.sort((a, b) => a[0] - b[0]);

  // Define output column headers
  const outputHeader = [
    'DATE',
    'TG_ADX_IMPRESSIONS',
    'TG_ADX_REVENUE',
    'TG_ADX_AD_REQUESTS',
    'TG_ADX_UNFILLED',
    'TG_ADX_ECPM',
    'CG_ADX_IMPRESSIONS',
    'CG_ADX_REVENUE',
    'CG_ADX_AD_REQUESTS',
    'CG_ADX_UNFILLED',
    'CG_ADX_ECPM',
    'ADX_ECPM_UPLIFT',
    'ADX_ECPM_%_UPLIFT',
    'ADX_REVENUE_UPLIFT',
    'TG_ADS_IMPRESSIONS',
    'TG_ADS_REVENUE',
    'TG_ADS_AD_REQUESTS',
    'TG_ADS_UNFILLED',
    'TG_ADS_ECPM',
    'CG_ADS_IMPRESSIONS',
    'CG_ADS_REVENUE',
    'CG_ADS_AD_REQUESTS',
    'CG_ADS_UNFILLED',
    'CG_ADS_ECPM',
    'ADS_ECPM_UPLIFT',
    'ADS_ECPM_%_UPLIFT',
    'ADS_REVENUE_UPLIFT',
  ];

  // Write header and data to sheet
  const outRange = outputSheet.getRange(
    1,
    1,
    resultRows.length + 1,
    outputHeader.length
  );
  outRange.setValues([outputHeader].concat(resultRows));
  
  // Apply formatting
  outputSheet.getRange(2, 1, resultRows.length, 1).setNumberFormat('yyyy-mm-dd'); // Date format
  outputSheet.getRange(2, 13, resultRows.length, 1).setNumberFormat('0.00%');      // AdX % Uplift
  outputSheet.getRange(2, 26, resultRows.length, 1).setNumberFormat('0.00%');      // AdS % Uplift

  // Add TOTALS row at the bottom
  const totalsRow = resultRows.length + 2;
  outputSheet.getRange(totalsRow, 1).setValue('TOTALS');
  
  // Helper function: Convert column number to Excel letter notation (A, B, C, ... AA, AB, etc.)
  function columnToLetter(column) {
    let temp, letter = '';
    while (column > 0) {
      temp = (column - 1) % 26;
      letter = String.fromCharCode(temp + 65) + letter;
      column = (column - temp - 1) / 26;
    }
    return letter;
  }
  
  // SUM formulas for volume and revenue columns (exclude date, eCPM, and percentage columns)
  // Columns: 2-5, 7-10, 14-18, 20-23, 27 (impressions, revenue, ad requests, unfilled, revenue uplift)
  const sumColumns = [2, 3, 4, 5, 7, 8, 9, 10, 14, 15, 16, 17, 18, 20, 21, 22, 23, 27];
  sumColumns.forEach(col => {
    const colLetter = columnToLetter(col);
    const formula = `=SUM(${colLetter}2:${colLetter}${totalsRow - 1})`;
    outputSheet.getRange(totalsRow, col).setFormula(formula);
  });
  
  // AVERAGE formulas for eCPM and percentage columns
  // Columns: 6, 11, 12, 13 (AdX metrics), 19, 24, 25, 26 (AdS metrics)
  const avgColumns = [6, 11, 12, 13, 19, 24, 25, 26];
  avgColumns.forEach(col => {
    const colLetter = columnToLetter(col);
    const formula = `=AVERAGE(${colLetter}2:${colLetter}${totalsRow - 1})`;
    outputSheet.getRange(totalsRow, col).setFormula(formula);
  });
  
  // Apply percentage formatting to totals row
  outputSheet.getRange(totalsRow, 13).setNumberFormat('0.00%'); // AdX % Uplift
  outputSheet.getRange(totalsRow, 26).setNumberFormat('0.00%'); // AdS % Uplift
}
